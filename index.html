<body>
<script>

const styles = []
const divs = []

function solve(a, b, c, d, x, y) {
  const det = a * d - b * c
  return [(d * x - b * y) / det, (a * y - c * x) / det]
}
const canvas = document.createElement('canvas')
const div = document.createElement('div')
canvas.width = canvas.height = 1024
;[canvas, div].forEach(el => document.body.appendChild(el))
function normalizeRadian(th, from = -Math.PI) {
  return th - Math.floor((th - from) / 2 / Math.PI) * 2 * Math.PI
}
function thetaDiff(t1, t2) {
  return normalizeRadian(t2 - t1)
}
function curveToSegments(p1, p2, recursive = true) {
  const cos1 = Math.cos(p1.th)
  const sin1 = Math.sin(p1.th)
  const cos2 = Math.cos(p2.th)
  const sin2 = Math.sin(p2.th)
  const th = Math.atan2(p2.y - p1.y, p2.x - p1.x)
  const length = Math.hypot(p2.x - p1.x, p2.y - p1.y)
  const thDiff = normalizeRadian(p2.th - p1.th)
  if (Math.max(Math.abs(normalizeRadian(p2.th - th)), Math.abs(normalizeRadian(p1.th - th))) < 1e-5) {
    return [[{ ...p1, length }], []]
  }
  let [la, lb] = solve(cos1, cos2, sin1, sin2, p2.x - p1.x, p2.y - p1.y)
  if (la < length / 8 || lb < length / 8 && recursive) {
    const a = { x: p1.x + cos1 * length / 3, y: p1.y + sin1 * length / 3 }
    const b = { x: p2.x - cos2 * length / 3, y: p2.y - sin2 * length / 3 }
    const th2 = Math.atan2(b.y - a.y, b.x - a.x)
    const center = { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2, th: th2 }
    const [ls1, cs1] = curveToSegments(p1, center, false)
    const [ls2, cs2] = curveToSegments(center, p2, false)
    return [[...ls1, ...ls2], [...cs1, ...cs2]]
  }
  if (la < 0 || lb < 0) return [[{ ...p1, length }], []]
  const r = Math.min(la, lb) * Math.tan((Math.PI - Math.abs(thDiff)) / 2)
  const base = la < lb ? p1 : p2
  const dir = thDiff > 0 ? 1 : -1
  const cx = base.x - r * dir * Math.sin(base.th)
  const cy = base.y + r * dir * Math.cos(base.th)
  let thStart = normalizeRadian(base.th - dir * Math.PI / 2)
  let thEnd = thStart + (la < lb ? 1 : -1) * thDiff
  if (thStart > thEnd) [thStart, thEnd] = [thEnd, thStart]
  const circle = { x: cx, y: cy, r }
  const line = { ...(la < lb ? p2 : p1), length: la - lb }
  const circles = []
  while (thStart < thEnd) {
    const t2 = Math.min(thEnd, (Math.floor(thStart / (Math.PI / 2)) + 1)* Math.PI / 2)
    circles.push({ ...circle, thStart, thEnd: t2 })
    thStart = t2
  }
  return [[line], circles]
}
function addCSSElement(base, before) {
  const el = document.createElement('i')
  div.appendChild(el)
  const selector = `i:nth-child(${div.children.length})`
  function cssToString(css) {
    const rules = []
    for (const key in css) {
      const value = ['left', 'top', 'width', 'height'].includes(key) ? Math.round(100 * css[key]) / 100 + 'px' : css[key]
      rules.push(key.replace(/[A-Z]/, v => '-' + v.toLocaleLowerCase()) + ':' + value + ';')
    }
    return rules.join('')
  }
  styles.push(`${selector}{${cssToString(base)}}`)
  styles.push(`${selector}:before{${cssToString(before)}}`)
}
function addLineCap({ x, y }, w) {
  addCSSElement(
    { left: x - w / 2, top: y - w / 2, width: w, height: w },
    {
      left: 0, top: 0, width: w, height: w,
      borderRadius: '50%',
      border: 'none',
      background: 'black'
    }
  )
}
function addCircle({ x, y, r, thStart, thEnd }, w) {
  const xs = []
  const ys = []
  ;[thStart, thEnd].forEach(th => {
    [-1, 1].forEach(wdir => {
      xs.push(x + (r + wdir * w / 2) * Math.cos(th))
      ys.push(y + (r + wdir * w / 2) * Math.sin(th))
    })
  })
  const left = Math.min(...xs)
  const top = Math.min(...ys)
  addCSSElement(
    { left, top, width: Math.max(...xs) - left, height: Math.max(...ys) - top },
    { left: x - left - r - w / 2, top: y - top - r - w / 2, width: 2 * r + w, height: 2 * r + w, borderRadius: '50%' }
  )
}
function addLine({ x, y, length, th }, w){
  const xs = []
  const ys = []
  const cos = Math.cos(th)
  const sin = Math.sin(th)
  ;[0, 1].forEach(t => {
    [-1, 1].forEach(wdir => {
      xs.push(x + t * length * cos + wdir * w / 2 * sin)
      ys.push(y + t * length * sin - wdir * w / 2 * cos)
    })
  })
  const left = Math.min(...xs)
  const top = Math.min(...ys)
  const center = { x: x + cos * length / 2, y: y + sin * length / 2 }
  const width = Math.abs(length) + w
  addCSSElement(
    { left, top, width: Math.max(...xs) - left, height: Math.max(...ys) - top },
    {
      left: center.x - left - width / 2,
      top: center.y - top - w / 2,
      width,
      height: w,
      transform: `rotate(${Math.round(th * 180 / Math.PI * 100) / 100}deg)`,
      background: 'black',
      border: 'none',
    }
  )
}
function curve(p1, p2, w) {
  const [lines, circles] = curveToSegments(p1, p2)
  const l = Math.hypot(p2.x - p1.x, p2.y - p1.y)
  const g = canvas.getContext('2d')
  g.save()
  g.beginPath()
  g.moveTo(p1.x, p1.y)
  g.bezierCurveTo(p1.x + l * Math.cos(p1.th) / 3, p1.y + l * Math.sin(p1.th) / 3, p2.x - l * Math.cos(p2.th) / 3, p2.y - l * Math.sin(p2.th) / 3, p2.x, p2.y)
  g.stroke()
  g.globalAlpha = 0.5
  g.lineWidth = 10
  circles.forEach((circle, i) => {
    g.globalAlpha = 0.5
    g.strokeStyle = ['red', 'blue'][i%2]
    g.beginPath()
    g.arc(circle.x, circle.y, circle.r, circle.thStart, circle.thEnd, circle.dir < 0)
    g.stroke()
    g.beginPath()
  })
  lines.forEach(line => {
    g.strokeStyle='green'
    g.moveTo(line.x, line.y)
    g.lineTo(line.x + line.length * Math.cos(line.th), line.y + line.length * Math.sin(line.th))
    g.stroke()
  })
  g.restore()
  circles.forEach(circle => addCircle(circle, w))
  lines.forEach(line => addLine(line, w))
  addLineCap(p1, w)
  addLineCap(p2, w)
}


const lineWidth = 10
curve({ x: 40, y: 40, th: 0.1 }, { x: 200, y: 200, th: 1 }, lineWidth)
curve({ x: 100, y: 20, th: 0.5 }, { x: 200, y: 200, th: 2 }, lineWidth)
curve({ x: 20, y: 300, th: 0.5 }, { x: 200, y: 300, th: 0.2 }, lineWidth)

const style = document.createElement('style')
const baseStyles = `
div,canvas{position:absolute;left:0;top:0}
div{position:absolute;box-shadow:0 0 1px red;}
i{position:absolute;overflow:hidden;box-shadow:0 0 1px black;}
i:before{content:'';position:absolute;box-sizing:border-box;border:${lineWidth}px solid black;transform-origin: center;}
`
style.textContent = baseStyles + '\n' + styles.join('\n')
document.head.appendChild(style)


</script>
